spring:
  application:
    name: openapi-mcp-server

  datasource:
    url: jdbc:derby:${DERBY_DB_PATH:./data/openapi_mcp};create=true
    driver-class-name: org.apache.derby.jdbc.EmbeddedDriver

  flyway:
    enabled: true
    locations: classpath:db/migration
    baseline-on-migrate: true

kubernetes:
  namespace-filter: ${K8S_NAMESPACE_FILTER:}
  openapi-path: ${OPENAPI_PATH:/v3/api-docs}
  # Custom URL template for OpenAPI discovery. Supports placeholders:
  # {service-name}, {namespace}, {cluster-ip}, {port}
  # Example: http://{service-name}.svc.example.com/{service-name}/v3/api-docs
  # If empty, defaults to: http://{cluster-ip}:{port}/{openapi-path}
  openapi-url-template: ${OPENAPI_URL_TEMPLATE:}
  discovery-label: ${DISCOVERY_LABEL:}
  in-cluster: ${K8S_IN_CLUSTER:false}
  kubeconfig-path: ${KUBECONFIG:~/.kube/config}

mcp:
  server:
    name: openapi-k8s-discovery
    version: 1.0.0
    description: MCP Server for discovering and invoking Kubernetes microservices via OpenAPI

openapi:
  fetch:
    timeout-seconds: ${OPENAPI_FETCH_TIMEOUT:30}
    retry-attempts: ${OPENAPI_FETCH_RETRIES:3}
    # Maximum concurrent requests to OpenAPI endpoints (rate limiting)
    max-concurrent-requests: ${OPENAPI_MAX_CONCURRENT_REQUESTS:10}
  backoff:
    # Consecutive failures before applying backoff
    max-failures: ${OPENAPI_BACKOFF_MAX_FAILURES:3}
    # Base backoff duration in seconds (doubles with each failure)
    base-seconds: ${OPENAPI_BACKOFF_BASE_SECONDS:60}
    # Maximum backoff duration in seconds (cap)
    max-seconds: ${OPENAPI_BACKOFF_MAX_SECONDS:3600}

scheduler:
  refresh:
    enabled: ${SCHEDULER_ENABLED:true}
    interval-ms: ${SCHEDULER_INTERVAL_MS:600000}

logging:
  level:
    co.fanki.openapimcp: ${LOG_LEVEL:INFO}
    io.kubernetes: WARN
    org.jdbi: ${JDBI_LOG_LEVEL:WARN}
